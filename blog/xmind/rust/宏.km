{"root":{"data":{"id":"8253bf73ea17","created":1535123812,"text":"宏","expandState":"expand"},"children":[{"data":{"id":"bnvfzppxhh4w","created":1535123860424,"text":"vec!宏示例","expandState":"expand"},"children":[{"data":{"id":"bnvfzppxxi8g","created":1535123860425,"text":"let x: Vec<u32> = vec![1, 2, 3];","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzppxjkwg","created":1535123860425,"text":"扩展开成为","expandState":"expand"},"children":[{"data":{"id":"bnvfzppy4cg0","created":1535123860425,"text":"let x: Vec<u32> = {\\n\tlet mut temp_vec = Vec::new();\\n\ttemp_vec.push(1);\\n\ttemp_vec.push(2);\\n\ttemp_vec.push(3);\\n\ttemp_vec\\n};","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzppy8tko","created":1535123860426,"text":"实现代码","expandState":"expand"},"children":[{"data":{"id":"bnvfzppyohkw","created":1535123860426,"text":"macro_rules! vec {\\n\t( $( $x:expr ),* ) => {\\n\t    {\\n\t        let mut temp_vec = Vec::new();\\n\t        $(\\n\t            temp_vec.push($x);\\n\t        )*\\n\t        temp_vec\\n\t    }\\n\t};\\n}","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzppy97kg","created":1535123860426,"text":"定义","expandState":"expand"},"children":[{"data":{"id":"bnvfzppyloo4","created":1535123860426,"text":"macro_rules! vec { ... }","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzppycnk8","created":1535123860426,"text":"匹配","expandState":"expand"},"children":[{"data":{"id":"bnvfzppyi5cg","created":1535123860426,"text":"( $( $x:expr ),* ) => { ... };","expandState":"expand"},"children":[{"data":{"id":"bnvfzppz1kow","created":1535123860427,"text":"像一个match表达式分支","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzppz8qw4","created":1535123860427,"text":"匹配发生在编译时 Rust 的语法树中","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzppza60w","created":1535123860427,"text":"最后一个分支的分号是可选的","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzppz5ag4","created":1535123860427,"text":"=>左侧的模式叫匹配器，有自己的语法","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzppytrsw","created":1535123860427,"text":"$x:expr将会匹配任何表rust达式，将语法树绑定到元变量$x上","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzppzbjco","created":1535123860428,"text":"expr标识符是一个片段分类符","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzppzr54o","created":1535123860428,"text":"匹配器写在$(..)中","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpq0ctcg","created":1535123860429,"text":"*会匹配 0 个或多个表达式，表达式之间用逗号分隔","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpq08ow0","created":1535123860429,"text":"展开","expandState":"expand"},"children":[{"data":{"id":"bnvfzppzyvc4","created":1535123860429,"text":"规则","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq0f9c0","created":1535123860429,"text":"展开中的重复与匹配器中的重复“同步”进行","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq011s8","created":1535123860429,"text":"$(\\n\ttemp_vec.push($x);\\n)*","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpq0r808","created":1535123860430,"text":"右侧有两对大括号","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq0pi8k","created":1535123860430,"text":"macro_rules! foo {\\n\t() => {{\\n\t    ...\\n\t}}\\n}","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpq0w1cs","created":1535123860430,"text":"外层的大括号是macro_rules!语法的一部分。事实上，你也可以()或者[]。它们只是用来界定整个右侧结构的。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpq0l6o0","created":1535123860430,"text":"内层大括号是展开语法的一部分。如果宏只展开一个单独的表达式，则不需要内层的大括号","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpq0p60o","created":1535123860430,"text":"重复","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq0ty8g","created":1535123860430,"text":"原则","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq1agow","created":1535123860431,"text":"$(...)*对它包含的所有$name都执行“一层”重复","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpq1h9ck","created":1535123860431,"text":"每个$name必须有至少这么多的$(...)*与其相对。如果多了，它将是多余的。","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpq1ia88","created":1535123860431,"text":"示例","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq21jsc","created":1535123860432,"text":"macro_rules! o_O {\\n\t(\\n\t    $(\\n\t        $x:expr; [ $( $y:expr ),* ]\\n\t    );*\\n\t) => {\\n\t    &[ $($( $x + $y ),*),* ]\\n\t}\\n}\\n\\nfn main() {\\n\tlet a: &[i32]\\n\t    = o_O!(10; [1, 2, 3];\\n\t           20; [4, 5, 6]);\\n\\n\tassert_eq!(a, [11, 12, 13, 24, 25, 26]);\\n}","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpq27bk8","created":1535123860432,"text":"卫生","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq1sq0o","created":1535123860432,"text":"示例","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq23g0s","created":1535123860432,"text":"macro_rules! five_times {\\n\t($x:expr) => (5 * $x);\\n}\\n\\nfn main() {\\n\tassert_eq!(25, five_times!(2 + 3));\\n}","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpq29mw4","created":1535123860432,"text":"元变量$x被解析成一个单独的表达式节点，并且在替换后依旧在语法树中保持原值。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpq2d008","created":1535123860433,"text":"每个宏展开都在一个不同的语法上下文中，并且每个变量在引入的时候都在语法中打了标记。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpq34tck","created":1535123860434,"text":"这也限制了宏在被执行时引入新绑定的能力。像这样的代码是不能工作的：","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq6vzsw","created":1535123860440,"text":"macro_rules! foo {\\n\t() => (let x = 3;);\\n}\\n\\nfn main() {\\n\tfoo!();\\n\tprintln!(\"{}\", x);\\n}","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpq9tuwo","created":1535123860445,"text":"相反你需要在执行时传递变量的名字，这样它会在语法上下文中被正确标记。","expandState":"expand"},"children":[{"data":{"id":"bnvfzpq9s6os","created":1535123860445,"text":"macro_rules! foo {\\n\t($v:ident) => (let $v = 3;);\\n}\\n\\nfn main() {\\n\tfoo!(x);\\n\tprintln!(\"{}\", x);\\n}","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqm014o","created":1535123860466,"text":"常用宏","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqm5tkw","created":1535123860466,"text":"panic!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqmg9sg","created":1535123860466,"text":"这个宏导致当前线程恐慌。","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqms4oo","created":1535123860467,"text":"panic!(\"oh no!\");","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqmwqgw","created":1535123860467,"text":"vec!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqmpeok","created":1535123860467,"text":"方便创建Vec<T>","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqmxpck","created":1535123860467,"text":"let v = vec![1, 2, 3, 4, 5];","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqn31ck","created":1535123860467,"text":"重复值创建vector。例如，100个0","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqn9y0c","created":1535123860468,"text":"let v = vec![0; 100];","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqnau8g","created":1535123860468,"text":"assert!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqnhwgk","created":1535123860468,"text":"获取一个布尔值","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqn6igw","created":1535123860468,"text":"assert!(true);","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqnjdsk","created":1535123860468,"text":"assert!(5 < 3);","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqnwnsc","created":1535123860469,"text":"true 就通过，false就panic!","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqnwk8c","created":1535123860469,"text":"assert_eq!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqognc4","created":1535123860470,"text":"获取两个值并比较它们","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqofgg0","created":1535123860470,"text":"assert_eq!(5, 3 + 2);","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqonq8k","created":1535123860470,"text":"assert_eq!(5, 3);","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqow54w","created":1535123860470,"text":"true 就通过，false就panic!","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqp1s84","created":1535123860471,"text":"try!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqpd9ck","created":1535123860471,"text":"try!用来进行错误处理。它获取一些可以返回Result<T, E>的数据，\\n并返回T如果它是Ok<T>，或return一个Err(E)如果出错了","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqp2w0k","created":1535123860471,"text":"use std::fs::File;\\n\\nfn foo() -> std::io::Result<()> {\\n\tlet f = try!(File::create(\"foo.txt\"));\\n\\n\tOk(())\\n}","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqoxyos","created":1535123860471,"text":"use std::fs::File;\\n\\nfn foo() -> std::io::Result<()> {\\n\tlet f = File::create(\"foo.txt\");\\n\\n\tlet f = match f {\\n\t    Ok(t) => t,\\n\t    Err(e) => return Err(e),\\n\t};\\n\\n\tOk(())\\n}","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqq2lck","created":1535123860472,"text":"unreachable!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqpxm8s","created":1535123860472,"text":"这个宏用于当你认为一些代码不应该被执行的时候","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqpu1kc","created":1535123860472,"text":"if false {\\n\tunreachable!();\\n}","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqppkw0","created":1535123860472,"text":"编译器可能会让你编写一个你认为将永远不会执行的不同分支。\\n在这个例子中，用这个宏，这样如果最终你错了，你会为此得到一个panic!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqpttcs","created":1535123860472,"text":"let x: Option<i32> = None;\\n\\nmatch x {\\n\tSome(_) => unreachable!(),\\n\tNone => println!(\"I know x is None!\"),\\n}","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqqelck","created":1535123860473,"text":"unimplemented!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqqqw0k","created":1535123860474,"text":"宏可以被用来当你尝试去让你的函数通过类型检查，同时你又不想操心去写函数体的时候。","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqr9nso","created":1535123860474,"text":"println!","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqrjmok","created":1535123860475,"text":"{}插入值请求","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqrgf4g","created":1535123860475,"text":"println!(\"The value of x is: {}\", x);","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqsh3sc","created":1535123860476,"text":"{:?}","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqut2go","created":1535123860480,"text":"format!(\"{:?}\", (3, 4));","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqy4g84","created":1535123860486,"text":"{value}","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqzm5ss","created":1535123860488,"text":"format!(\"{value}\", value=4);","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpr0nqgo","created":1535123860490,"text":"{:04}","expandState":"expand"},"children":[{"data":{"id":"bnvfzpr09kw0","created":1535123860490,"text":"format!(\"{:04}\", 42);","expandState":"expand"},"children":[{"data":{"id":"bnvfzpr184gk","created":1535123860491,"text":"0042","expandState":"expand"},"children":[]}]}]}]}]},{"data":{"id":"bnvfzpqbrmok","created":1535123860448,"text":"调试宏代码","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqbr6gc","created":1535123860448,"text":"查看宏展开后的结果","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqc9awc","created":1535123860449,"text":"rustc --pretty expanded","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqdi800","created":1535123860451,"text":"--pretty expanded,hygiene","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqdd2os","created":1535123860451,"text":"语法上下文的信息","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqdmrk0","created":1535123860452,"text":"功能入口（feature gates）","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqe27ks","created":1535123860452,"text":"log_syntax!(...)会打印它的参数到标准输出，在编译时，并且不“展开”任何东西。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqe4d4c","created":1535123860452,"text":"trace_macros!(true)每当一个宏被展开时会启用一个编译器信息。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqec3cw","created":1535123860453,"text":"trace_macros!(false)关闭","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqeqzkk","created":1535123860453,"text":"句法要求","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqfpegc","created":1535123860455,"text":"Rust 宏系统设计的推论","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqfu144","created":1535123860455,"text":"当它解析一个宏展开时，宏是否代替了","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqfklk4","created":1535123860455,"text":"0个或多个项\\n0个或多个方法\\n一个表达式\\n一个语句\\n一个模式","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqgksg0","created":1535123860456,"text":"展开前的宏必须是","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqh1oo4","created":1535123860457,"text":"用大括号界定的，例如foo! { ... }","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqhg9kc","created":1535123860458,"text":"分号结尾的，例如foo!(...);","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqhlw08","created":1535123860458,"text":"宏展开必须包含有效的Rust记号","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqh7j4g","created":1535123860458,"text":"括号，中括号，大括号在宏展开中必须是封闭的","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqh87c4","created":1535123860458,"text":"foo!([)是不允许的","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqibfcc","created":1535123860459,"text":"让Rust知道宏何时结束","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqib74s","created":1535123860459,"text":"宏展开体必须是一个记号树（token trees）的序列","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqic8w0","created":1535123860459,"text":"一个记号树是一系列递归的","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqi30g0","created":1535123860459,"text":"一个由()，[]或{}包围的记号树序列","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqhzkg8","created":1535123860459,"text":"任何其它单个记号","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqie7co","created":1535123860460,"text":"片段分类符","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqixg08","created":1535123860460,"text":"在一个匹配器中，每一个元变量都有一个片段分类符（fragment specifier），确定它匹配的哪种句法","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqistck","created":1535123860460,"text":"常见","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqijbk8","created":1535123860460,"text":"ident：一个标识符。例如：x，foo\\npath：一个受限的名字。例如：T::SpecialA\\nexpr：一个表达式。例如：2 + 2；if true then { 1 } else { 2 }；f(42)\\nty：一个类型。例如：i32；Vec<(char, String)>；&T\\npat：一个模式。例如：Some(t)；(17, 'a')；_\\nstmt：一个单独语句。例如：let x = 3\\nblock：一个大括号界定的语句序列，或者一个表达式。例如：{ log(error, \"hi\"); return 12; }\\nitem：一个项。例如：fn foo() { }，struct Bar\\nmeta：一个“元数据项”，可以在属性中找到。例如：cfg(target_os = \"windows\")\\ntt：一个单独的记号树","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqjdag4","created":1535123860461,"text":"元变量后面的一个记号的规则","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqj2owg","created":1535123860461,"text":"expr和stmt变量必须后跟任意一个：=> , ;\\nty和path变量必须后跟任意一个：=> , = | ; : > [ { as where\\npat变量必须后跟任意一个：=> , = | if in\\n其它变量可以后跟任何记号","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqjf08w","created":1535123860461,"text":"宏系统完全不处理解析模糊","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqjfpk4","created":1535123860461,"text":"$($i:ident)* $e:expr语法总是会解析失败，\\n因为解析器会被强制在解析$i和解析$e之间做出选择。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqjbjks","created":1535123860461,"text":"可以写成$(I $i:ident)* E $e:expr","expandState":"expand"},"children":[]}]}]}]},{"data":{"id":"bnvfzpqizegw","created":1535123860461,"text":"范围和宏导入/导出","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqjs4ws","created":1535123860462,"text":"与语言中其它结构相比，范围对宏的作用不一样","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqjz94w","created":1535123860462,"text":"定义和展开都发生在同一个深度优先、字典顺序的包装箱的代码遍历中。\\n那么在模块范围内定义的宏对同模块的接下来的代码是可见的，\\n这包括任何接下来的子mod项。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqjr1ko","created":1535123860462,"text":"一个定义在fn函数体内的宏，或者任何其它不在模块范围内的地方，只在它的范围内可见。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqk41kw","created":1535123860462,"text":"如果一个模块有macro_use属性，它的宏在子mod项之后的父模块也是可见的。\\n如果它的父模块也有macro_use属性那么在父mod项之后的祖父模块中也是可见的，以此类推。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqjokoo","created":1535123860462,"text":"macro_use属性也可以出现在extern crate处。\\n在这个上下文中它控制那些宏从外部包装箱中装载","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqk49kc","created":1535123860462,"text":"#[macro_use(foo, bar)]\\nextern crate baz;","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqknu8s","created":1535123860463,"text":"如果属性只是简单的写成#[macro_use]，所有的宏都会被装载。\\n如果没有#[macro_use]属性那么没有宏被装载。\\n只有被定义为#[macro_export]的宏可能被装载。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqkcg00","created":1535123860463,"text":"装载一个包装箱的宏而不链接到输出，使用#[no_link]","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqkj4g8","created":1535123860463,"text":"示例","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqkknc4","created":1535123860463,"text":"macro_rules! m1 { () => (()) }\\n\\n// Visible here: `m1`.\\nmod foo {\\n\t// Visible here: `m1`. \\n #[macro_export] \\n macro_rules! m2 { () => (()) }\\n\t// Visible here: `m1`, `m2`.\\n}\\n// Visible here: `m1`.\\nmacro_rules! m3 { () => (()) }\\n// Visible here: `m1`, `m3`.\\n\\n#[macro_use]\\nmod bar {\\n\t// Visible here: `m1`, `m3`. \\n macro_rules! m4 { () => (()) }\\n\t// Visible here: `m1`, `m3`, `m4`.\\n}\\n\\n// Visible here: `m1`, `m3`, `m4`.\\n# fn main() { }","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqkncgs","created":1535123860463,"text":"当这个库被用#[macro_use] extern crate装载时，只有m2会被导入。","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bnvfzpqkzqgo","created":1535123860464,"text":"$crate变量","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqkuy8s","created":1535123860464,"text":"当一个宏在多个包装箱中使用时会产生一个困难","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqkvrc4","created":1535123860464,"text":"pub fn increment(x: u32) -> u32 {\\n\tx + 1\\n}\\n\\n#[macro_export]\\nmacro_rules! inc_a {\\n\t($x:expr) => ( ::increment($x) )\\n}\\n#[macro_export]\\nmacro_rules! inc_b {\\n\t($x:expr) => ( ::mylib::increment($x) )\\n}","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpql83cw","created":1535123860464,"text":"inc_a只能在mylib内工作，同时inc_b只能在库外工作。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqle6o8","created":1535123860465,"text":"当从一个叫foo的包装箱总导入宏时，特殊宏变量$crate会展开为::foo","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqlxuwo","created":1535123860465,"text":"当这个宏在同一包装箱内定义和使用时，$crate将展开为空。","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpqlhwoo","created":1535123860465,"text":"#[macro_export]\\nmacro_rules! inc {\\n\t($x:expr) => ( $crate::increment($x) )\\n}\\n# fn main() { }","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqle28s","created":1535123860465,"text":"深入","expandState":"expand"},"children":[{"data":{"id":"bnvfzpqlpgoo","created":1535123860465,"text":"递归宏","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpr16w0k","created":1535123860491,"text":"宏程序","expandState":"expand"},"children":[{"data":{"id":"bnvfzpr13rsc","created":1535123860491,"text":"语法扩展插件有时被称为宏程序","expandState":"expand"},"children":[]},{"data":{"id":"bnvfzpr13tkc","created":1535123860491,"text":"编译器插件","expandState":"expand"},"children":[]}]},{"data":{"id":"bnvfzpqa8l4w","created":1535123860446,"text":"递归宏","expandState":"expand"},"children":[]}]},"template":"right","theme":"classic-compact","version":"1.4.43"}